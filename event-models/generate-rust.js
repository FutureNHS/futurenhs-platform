const { promises: fs } = require("fs");

const toSnakeCase = (str) =>
  str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);

const toRustType = (definition) => {
  // TODO: handle enums
  switch (definition.type) {
    case "integer":
      return "i64";
    case "string":
      switch (definition.format) {
        case "date-time":
          return "DateTime<Utc>";
        case undefined:
          return "String";
        default:
          throw new Error(`Unsupported format: ${definition.format}`);
      }
    default:
      throw new Error(`Unsupported type: ${definition.type}`);
  }
};

const createStruct = (name, definition) => {
  if (definition.type !== "object") {
    throw new Error("Can only build struct for object types");
  }

  return `
    /// ${definition.description ?? ""}
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct ${name} {
      ${Object.entries(definition.properties)
        .map(([propName, propDefinition]) => {
          let isRequired = definition.required.includes(propName);
          let type = toRustType(propDefinition);
          let serdeOptions = [`rename = "${propName}"`];
          if (!isRequired) {
            type = `Option<${type}>`;
            serdeOptions.push('skip_serializing_if = "Option::is_none"');
          }

          return `
            /// ${propDefinition.description ?? ""}
            #[serde(${serdeOptions.join(", ")})]
            pub ${toSnakeCase(propName)}: ${type},
          `;
        })
        .join("")}
    }
  `;
};

const generateRustModels = (schema) => {
  // This code generation has a very limited understanding of JSON schema. It
  // assumes it to be in a very specific structure. We do a few quick
  // assertions here to catch if anything big has changed.
  if (
    schema.title !== "Event" ||
    schema.allOf?.length !== 2 ||
    schema.allOf[0].$ref !== "#/definitions/BaseEvent" ||
    schema.allOf[1].oneOf?.some((x) => !x.$ref.startsWith("#/definitions/"))
  ) {
    throw new Error("Unsupported JSON schema");
  }

  const dataStructs = [];
  const eventDataVariants = [];
  const fromImplementations = [];
  const deserializeMatchArms = [];
  const serializeMatchArms = [];
  for (const name of schema.allOf[1].oneOf.map((x) =>
    x.$ref.split("/").pop()
  )) {
    const definition = schema.definitions[name];
    if (!definition) {
      throw new Error(`Cannot find definition for ${name}`);
    }

    const eventType = definition.properties.eventType.enum[0];
    const dataVersion = definition.properties.dataVersion.enum[0];

    dataStructs.push(createStruct(`${name}Data`, definition.properties.data));
    eventDataVariants.push(`${name}(${name}Data),`);
    fromImplementations.push(`
      impl From<${name}Data> for EventData {
        fn from(data: ${name}Data) -> Self {
          Self::${name}(data)
        }
      }
    `);
    deserializeMatchArms.push(`
      ("${eventType}", "${dataVersion}") => Ok(Self::${name}(
        serde_json::from_value(data).map_err(EventDataDeserializationError::Json)?,
      )),
    `);
    serializeMatchArms.push(`
      Self::${name}(data) => ("${eventType}", "${dataVersion}", serde_json::to_value(data)?),
    `);
  }

  return `
    // This file was automatically generated by yarn generate.
    // DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
    // and run yarn generate to regenerate this file.

    use chrono::{DateTime, Utc};
    use serde::{Deserialize, Serialize};

    ${dataStructs.join("")}

    #[derive(Debug, PartialEq, Clone)]
    pub enum EventData {
      ${eventDataVariants.join("")}
    }

    ${fromImplementations.join("")}

    pub(crate) enum EventDataDeserializationError {
      Json(serde_json::Error),
      UnknownVariant,
    }

    impl EventData {
      pub(crate) fn deserialize(
        event_type: &str,
        data_version: &str,
        data: serde_json::Value,
      ) -> Result<Self, EventDataDeserializationError> {
        match (event_type, data_version) {
          ${deserializeMatchArms.join("")}
          (_, _) => Err(EventDataDeserializationError::UnknownVariant),
        }
      }

      pub(crate) fn serialize(
          &self,
      ) -> Result<(&'static str, &'static str, serde_json::Value), serde_json::Error> {
        Ok(match self {
          ${serializeMatchArms.join("")}
        })
      }
    }
  `;
};

const main = async () => {
  const schema = JSON.parse(
    await fs.readFile(`${__dirname}/schema.json`, "utf8")
  );
  const rs = generateRustModels(schema);
  await fs.writeFile(`${__dirname}/rust/src/models/generated.rs`, rs, "utf8");
};

main().catch((e) => {
  console.error(e);
  process.exitCode = 1;
});
